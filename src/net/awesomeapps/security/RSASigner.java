package net.awesomeapps.security;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import net.awesomeapps.security.io.PemObject;
import net.awesomeapps.security.io.PemWriter;

public class RSASigner {
	
	/**
	 * Sign the given data with a private key. Use {@link RSASigner#getPrivateKey(File)} 
	 * to get a PrivateKey object to use with this method.
	 * 
	 * The results of this method should be used to verify the signature at a later time.
	 * 
	 * @param data
	 * 				The data to sign
	 * @param privateKey
	 * 				The private key used to sign the data. Use {@link RSASigner#getPrivateKey(File)}
	 * @param signatureAlgo
	 * 				The RSA signature algorithm to use
	 * @return
	 * 				The signature as a byte array
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static byte[] sign(byte[] data, PrivateKey privateKey, String signatureAlgo) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		
		// Instance of our signing algo
		Signature rsa = Signature.getInstance(signatureAlgo);
		
		// Sign with our private key
		rsa.initSign(privateKey);
		rsa.update(data);
		
		// Return the signature
		return rsa.sign();
	}
	
	/**
	 * Sign the given data with a private key. Uses default signature algorithm "SHA1withRSA".
	 * 
	 * @param data
	 * 				The data to sign
	 * @param privateKey
	 * 				The private key used to sign the data. Use {@link RSASigner#getPrivateKey(File)}
	 * @return
	 * 				The signature as a byte array
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static byte[] sign(byte[] data, PrivateKey privateKey) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		
		return sign(data, privateKey, RSA.SHA1_RSA);
	}
	
	/**
	 * Verify the signature of the given data. Use {@link RSASigner#getPublicKey(File)} to
	 * get a PublicKey object to use with this method.
	 * 
	 * @param data
	 * 				The data to verify the signature of
	 * @param signature
	 * 				The signature of the data generated by {@link RSASigner#sign(byte[], PrivateKey)}
	 * @param publicKey
	 * 				The PublicKey object to verify the signature. Use {@link RSASigner#getPublicKey(File)}
	 * @param signatureAlgo
	 * 				The RSA signature algorithm to use
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static boolean verify(byte[] data, byte[] signature, PublicKey publicKey, String signatureAlgo) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		
		// Instance of our signing algo
		Signature sig = Signature.getInstance(signatureAlgo);
		
		// Set the public key of our signing key and data
		sig.initVerify(publicKey);
		sig.update(data);

		// Validate that the given signature matching the provided key and data
		return sig.verify(signature);
	}
	
	/**
	 * Verify the signature of the given data. Uses default signature algorithm "SHA1withRSA".
	 * 
	 * @param data
	 * 				The data to verify the signature of
	 * @param signature
	 * 				The signature of the data generated by {@link RSASigner#sign(byte[], PrivateKey)}
	 * @param publicKey
	 * 				The PublicKey object to verify the signature. Use {@link RSASigner#getPublicKey(File)}
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static boolean verify(byte[] data, byte[] signature, PublicKey publicKey) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		
		return verify(data, signature, publicKey, RSA.SHA1_RSA);
	}
	
	/**
	 * Get a PublicKey object for the given public key file. The key file must 
	 * only contain the encoded bytes. 
	 * 
	 * @param keyFile
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 * @throws IOException
	 */
	public static PublicKey getPublicKey(File keyFile) 
			throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {
		
		if (!keyFile.exists()) {
			throw new IOException(String.format("Key file '%s' does not exist.", keyFile.getAbsolutePath()));
		}
		
		byte[] keyBytes = Files.readAllBytes(keyFile.toPath());
		return getPublicKey(keyBytes);
	}
	
	/**
	 * Get a PublicKey object for the given public key file that was created using
	 * {@link PemWriter#write(File, PemObject)}
	 * 
	 * @param pemObject
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 * @throws IOException
	 */
	public static PublicKey getPublicKey(PemObject pemObject) 
			throws NoSuchAlgorithmException, InvalidKeySpecException {
		
		return getPublicKey(pemObject.getContent());
	}
	
	/**
	 * Get a PublicKey object from the given byte array contents.
	 * 
	 * @param content
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 */
	public static PublicKey getPublicKey(byte[] content) 
			throws NoSuchAlgorithmException, InvalidKeySpecException {
		
		X509EncodedKeySpec spec = new X509EncodedKeySpec(content);
		KeyFactory kf = KeyFactory.getInstance(RSA.KEY_ALGO);
		
		return kf.generatePublic(spec);
	} 
	
	/**
	 * Get a PrivateKey object for the given private key file. The key file must 
	 * only contain the encoded bytes. 
	 * 
	 * @param keyFile
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 * @throws IOException
	 */
	public static PrivateKey getPrivateKey(File keyFile) 
			throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {
		
		if (!keyFile.exists()) {
			throw new IOException(String.format("Key file '%s' does not exist.", keyFile.getAbsolutePath()));
		}
		
		byte[] keyBytes = Files.readAllBytes(keyFile.toPath());
		return getPrivateKey(keyBytes);
	}
	
	/**
	 * Get a PrivateKey object for the given public key file that was created using
	 * {@link PemWriter#write(File, PemObject)}
	 * 
	 * @param pemObject
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 */
	public static PrivateKey getPrivateKey(PemObject pemObject) 
			throws NoSuchAlgorithmException, InvalidKeySpecException {
		
		return getPrivateKey(pemObject.getContent());
	}
	
	/**
	 * Get a PrivateKey object from the given byte array contents.
	 * 
	 * @param contents
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeySpecException
	 */
	public static PrivateKey getPrivateKey(byte[] contents) 
			throws NoSuchAlgorithmException, InvalidKeySpecException {
		
		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(contents);
		KeyFactory kf = KeyFactory.getInstance(RSA.KEY_ALGO);
		
		return kf.generatePrivate(spec);
	}
	
}
